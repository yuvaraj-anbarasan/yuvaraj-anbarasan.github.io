<!DOCTYPE html>
<html>
    <head>
        <link rel="stylesheet" type="text/css" href="style.css">
    </head>
    <body>
        <nav>
            <ul>
                <li><a href="../assets/resume/Yuvaraj_A-resume.pdf">RESUME</a></li>
                <li><a>PROJECTS</a></li>
                <li><a>ABOUT</a></li>
                <li><a>HOME</a></li>
            </ul>
        </nav>
        <div class="report-body">
            <div id="gsoc-logo">
                <img src="./../assets/icons/GSoC-logo.png">
                <h3>2020</h3>
            </div>
            <h2 id="project-title">Java 11 support for jpf-core</h2>
            <h3 id="author-name">by Yuvaraj Anbarasan</h3>
            <div id="about-jpf">
                <div>
                    <h3>About <a href="https://github.com/javapathfinder/jpf-core"> Java Pathfinder</h3>
                    <img src="../assets/icons/github-logo.png">
                    </a>
                </div>
                <p>Java Pathfinder (JPF) is a model checking tool for Java applications. <a href="https://github.com/javapathfinder/jpf-core">JPF-core</a> is the core structure of
                    JPF. It is a Virtual Machine (VM) for Java bytecode which executes the system under
                    test (SUT). While the execution semantics of Java bytecodes are clearly defined in Sun's 
                    Java virtual machine specifications, the semantics are hardwired in JPF - the VM 
                    instruction set is represented by a set of classes that can be replaced. JPF is a special VM.
                    JPF itself is written in Java, so it is not as fast as your normal Java. That implies that JPF is VM
                    which is running on top of another VM.
                </P>
                <P>    
                    As JPF executes the SUT, it checks for certain properties which are given to JPF as input. 
                    Some of the properties that can be checked by JPF are unhandled exceptions, deadlocks, 
                    and user-defined assertions which are used to test properties of the code's behavior. 
                    After the execution of the SUT, JPF gives a detailed report on the properties which hold 
                    and verification artifacts that have been created by JPF for further analysis (like test cases).                        
                </p>
            </div>
            <div id="work-summary">
                    <h3>Work summary</h3>
                    <p>
                        My task was to support JPF for java version 11 and 12.    
                    </p>
            </div>
            <div id="overview">
                <h3>Overview</h3>
                <p>
                    The arrival of Java 9 introduced some interesting changes like the module system, handling strings, etc 
                    to the javac compiler and the Java internals. These changes caused various issues in JPF since a lot classes
                    are dependent on the host JVM's implementation.
                </p>
                <div>
                    <p>
                        JPF can be viewed as a Java Virtual Machine (JVM) in itself. JPF has it's own implementation of the VM. Basically,
                        JPF is a virtual machine (VM) running on top of the JVM. The class (.class) files at times are processed in two different ways 
                        in a JVM running JPF-core
                    </p>
                    <ul>
                        <li>as any other Java classes managed and executed by the host JVM (standard Java library classes, JPF implementation classes)</li>
                        <li>as "modeled" classes managed and processed (verified) by JPF</li>
                    </ul>
                </div>
                <p>
                    Each standard JVM supports a so called Java Native Interface (JNI), that is used to delegate execution from the Java level 
                    (i.e. JVM controlled bytecode) down into the (platform dependent) native layer (native method libraries). 
                    The primary goal is binary compatibility of native method libraries across all Java virtual machine implementations on a given 
                    platform.
                </p>
                <p>
                    Interestingly enough, there exists a analogous need to lower the "execution" level in JPF, from JPF controlled bytecode into JVM 
                    controlled bytecode. According to this analogy, the JPF specific interface is called Model Java interface (MJI), which is used to
                    find or check mangled version of the native method when JPF encounters a native method.
                </p>
                <p>
                    JPF also has its own set of model classes which are used as a substitute for the JVM classes. The main reason for having model 
                    classes is that a lot of the functionalities can be implemented that native methods have in simple Java code. Sometimes there is a
                    need to delegate the execution of a method to the host JVM and this is again done by declaring a function native using the native keyword.
                </p>
                <p>
                    Since the native method implementation of JPF is depenedent on the host JVM's implementation, a lot of issues occured when migrating JPF from
                    java 8 to 11.
                </p>
            </div>
            
            <div id="pull-requests">
                <h3>Pull Requests</h3>
                <div class="pr">
                    <a href="https://github.com/javapathfinder/jpf-core/pull/223" class="pr-link">
                        <h4>#223</h4>
                    </a>
                    <div class="issues">
                        <label>related issues: </label>
                        <label class="no-issues">no issues</label>
                    </div>
                    <div class="my-work">
                        <p>
                            Added missing methods in <label class="highlight-text">jdk.internal.misc.Unsafe</label> native peer. 
                            Few methods were deprecated and new methods were introduced in java-12. This patch includes the missing 
                            methods and its implementation in <label class="highlight-text">jdk.internal.misc.Unsafe</label></label> native peer.
                        </p>
                    </div>
                </div>
                <div class="pr">
                    <a href="https://github.com/javapathfinder/jpf-core/pull/227" class="pr-link">
                        <h4>#227</h4>
                    </a>
                    <div class="issues">
                        <label>related issues: </label>
                        <label class="no-issues">no issues</label>
                    </div>
                    <div class="my-work">
                        <p>
                            Fixed <label class="highlight-text">java.lang.String</label> native peer <label class="highlight-text">computeStringHashCode</label> 
                            method. Previously (in java 8 and lower versions), String values were stored as characters, hence the hash was computed as,
                            <div class="highlight-block">
                            s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]
                            </div>
                            were s[i] was character. This chnaged in java 9 and above versions, were s[i] is of type byte. Therefore, the existing logic didn't
                            work since it tried to get char array instead of byte array. This PR fixed this issue by changing the logic to get byte array.                        
                        </p>
                    </div>
                </div>
                <div class="pr">
                    <a href="https://github.com/javapathfinder/jpf-core/pull/232" class="pr-link">
                        <h4>#232</h4>
                    </a>
                    <div class="issues">
                        <label>related issues: </label>
                        <a href="https://github.com/javapathfinder/jpf-core/issues/231">#231</a>
                    </div>
                    <div class="my-work">
                        <p>
                            Added and implemented <label class="highlight-text">checkOutOffBounds</label> method in <label class="highlight-text">java.lang.String</label>
                            model class. <label class="highlight-text">checkOutOffBounds</label> method checks for 
                            <label class="highlight-text">StringIndexOutOfBoundsException</label> by checking the string's offset is negative or greater than 
                            the length.
                        </p>
                    </div>
                </div>
                <div class="pr">
                    <a href="https://github.com/javapathfinder/jpf-core/pull/241" class="pr-link">
                        <h4>#241</h4>
                    </a>
                    <div class="issues">
                        <label>related issues: </label>
                        <a href="https://github.com/javapathfinder/jpf-core/issues/238">#238</a>
                        <a href="https://github.com/javapathfinder/jpf-core/issues/239">#239</a>
                    </div>
                    <div class="my-work">
                        <p>
                            Since module system was introduced in java 9, <label class="highlight-text">Package.getPackages</label> inernally calls the 
                            <label class="highlight-text">Module</label> class method which again calls <label class="highlight-text">Package</label> class,
                            and as a result of mutual dependency between the two classes, the call to <label class="highlight-text">Package.getPackges</label>
                             was going into an infinite loop, causing a StackOverFlowError.
                        </p>
                        <p>
                            This issue occured because the logic in setting bootstrap method (<label class="highlight-text">JVMClassInfo.setBootstrapMethod</label>) to get 
                            enclosing lambda or class, was unable to partially resolve the classes. Hence everytime when enclosing class 
                            was not found, the class of again loaded if not already resolved. In this case, before Package class getting 
                            fully resolved, the Module class was called which again was not resolved. Hence resulted to infinte loop.
                        </p>
                        <p>
                            This issue was fixed by adding model class for Module class. Since the model classes are already resolved at JPF load time, when 
                            <label class="highlight-text">Package</label> classcalls <label class="highlight-text">Module</label> class, the classLoader 
                            fetches the resolved model class.
                        </p>
                        <p>
                            Another issue was related to Package class initialization. A few fields related to Package was missing and were moved to the inner class of
                            Package. Hence the issue was solved by initializing the fields inside the inner class.
                        </p>
                    </div>
                </div>
                <div class="pr">
                    <a href="https://github.com/javapathfinder/jpf-core/pull/242" class="pr-link">
                        <h4>#242</h4>
                    </a>
                    <div class="issues">
                        <label>related issues: </label>
                        <a href="https://github.com/javapathfinder/jpf-core/issues/233">#233</a>
                    </div>
                    <div class="my-work">
                        <p>
                            Added and implemented missing methods <label class="highlight-text">getDefinedPacage</label> and 
                            <label class="highlight-text">getDefinedPacages</label> to <label class="highlight-text">java.lang.ClassLoader</label> model and native peer 
                            classes
                        </p>
                    </div>
                </div>
                <div class="pr">
                    <a href="https://github.com/javapathfinder/jpf-core/pull/245" class="pr-link">
                        <h4>#245</h4>
                    </a>
                    <div class="issues">
                        <label>related issues: </label>
                        <label class="no-issues">no issues</label>
                    </div>
                    <div class="my-work">
                        <p>
                            Added module path to class path. <label class="highlight-text">ClassLoader.getResource</label> was failing to fetch resource because
                            the class path was missing module path.
                        </p>
                    </div>
                </div>
                <div class="pr">
                    <a href="https://github.com/javapathfinder/jpf-core/pull/247" class="pr-link">
                        <h4>#247</h4>
                    </a>
                    <div class="issues">
                        <label>related issues: </label>
                        <a href="https://github.com/javapathfinder/jpf-core/issues/246">#246</a>
                    </div>
                    <div class="my-work">
                        <p>
                            Modified <label class="highlight-text">ClassLoader.getResources</label> method logic. The <label class="highlight-text">ClassLoader.getResources</label>
                            returns an <label class="highlight-text">Enumeration</label>. Previously, the method used an <label class="highlight-text">ArrayList</label> 
                            to store the resource URLs and converts the <label class="highlight-text">ArrayList</label> to <label class="highlight-text">Enumeration</label>, 
                            which is returned. The URLs were not able to be added because of type mismatch which occured because of changes in host jvm's implementation.
                        </p>
                        <p>
                            This issue was fixed by storing the resource URL's in an Enumeration insted of storing it in an <label class="highlight-text">ArrayList</label>
                            and returning the converted <label class="highlight-text">Arraylist</label>.
                        </p>
                    </div>
                </div>
                <div class="pr">
                    <a href="https://github.com/javapathfinder/jpf-core/pull/249" class="pr-link">
                        <h4>#249</h4>
                    </a>
                    <div class="issues">
                        <label>related issues: </label>
                        <label class="no-issues">no issues</label>
                    </div>
                    <div class="my-work">
                        <p>
                            Removed model class for <label class="highlight-text">Module</label> class and added logic to get partially resolved classes when 
                            seting bootstrap method. Added <label class="highlight-text">Module.getModuleName</label> method to model and native peer classes
                            to get module name of a class. The method is implemented in the native peer to make use of the host JVM's <label class="highlight-text">Class.getModule</label>. 
                            Using this, and based on whether the resolved or loaded class is JPF class or not, the module name was added to
                            the class path in <label class="highlight-text">Class.getResource</label> accordingly. This fixed the issue with 
                            <label class="highlight-text">Class.getResource</label>.
                        </p>
                    </div>
                </div>
                <div class="pr">
                    <a href="https://github.com/javapathfinder/jpf-core/pull/257" class="pr-link">
                        <h4>#257</h4>
                    </a>
                    <div class="issues">
                        <label>related issues: </label>
                        <a href="https://github.com/javapathfinder/jpf-core/issues/256">#256</a>
                    </div>
                    <div class="my-work">
                        <p>
                            Added <label class="highlight-text">getUnalignedLong</label> method to <label class="highlight-text">jdk.internal.misc.Unsafe</label>
                            class native peer. The implementation of <label class="highlight-text">Arrays.equals</label> was changed since java 9. It leverages vector-based techniques to access and
                             compare the contents of two arrays (to make the comparison efficient). To access the contents of the array, 
                             <label class="highlight-text">Unsafe.getLongUnaligned</label> is used. This method uses Unsafe.getLong to get value of the array based on the offset value.
                        </p>
                        <p>
                            Since, the type of the array was not long, JPF was throwing an exception. This was becasue the offset value passed to 
                            <label class="highlight-text">Unsafe.getLongUnaligned</label> method was the index of the array instead of the offset value. 
                            The offset value should have been,
                        </p>
                        <div class="highlight-block">
                            ((array Object's base index) - (offset of long type)) - ((array Object's base index) - (offset of array type (i.e, int, float, double, etc)))
                        </div>
                        <p>
                            Hence <label class="highlight-text">Unsafe.getLongUnaligned</label> logic was not woking as expected. And since the method calculating 
                            is a host JVM class, the solution to this issue was to add and implement <label class="highlight-text">Unsafe.getLongUnaligned</label> in 
                            <label class="highlight-text">Unsafe</label> native peer class. 
                            The native peer method, uses the type of the array instead of offset to return the right value.
                        </p>
                    </div>
                </div>
            </div>
            <div id="conclusion">
                <h3>Conclusion</h3>
                <p>
                    It was a great experience working for three months on my project for Java Pathfinder under Google Summer of Code. 
                    I sincerely thank my mentors <label class="bold-text">Cyrille Artho</label> and <label class="bold-text">Pavel Pavel</label> Parizek whose support, guidance and continuous encouragement helped me immensely 
                    in bringing this work where it stands.
                </p>
                <p>
                    Thanks, Google and Java Pathfinder for giving me this opportunity. 
                </p>
            </div>
        </div>

        <footer>
            <div class="footer-content">
                <div class="column">
                    <a href="https://www.linkedin.com/in/yuvaraj-anbarasan-b2626a168/">
                        <img src="../assets/icons/footer-icons/linkedIn.jpeg">
                        <br>
                        <label>LinkedIn</label>
                    </a>
                </div>
                <div class="column">
                    <a href="https://github.com/yuvaraj-anbarasan">
                        <img src="../assets/icons/footer-icons/github.png">
                        <br>
                        <label>GitHub</label>
                    </a>
                </div>
                <div class="column">
                    <a href="mailto:yuvaraj.klei@gmail.com">
                        <img id="gmail" src="../assets/icons/footer-icons/gmail.png">
                        <br>
                        <label>Gmail</label>
                    </a>
                </div>
            </div>
        </footer>
    </body>
</html>